<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>String to Number Conversion in C Takes its Toll ← Machinae Elegantiam</title><meta name="author" content="Russell Harmon"/><link rel="stylesheet" href="/css/reset.css" type="text/css"/><link rel="stylesheet" href="/css/screen.css" type="text/css"/><link rel="stylesheet" href="/css/960.css" type="text/css"/><link rel="stylesheet" href="/css/syntax.css" type="text/css"/><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Walter+Turncoat:regular"/><meta name="keywords" content="programming,c,strtol,string conversion"/><meta name="description" content="Converting a string to a number in C is no simple affair."/></head><body id=""><div id="site"><div id="header"><h1> <span class="nav"> <a href="/machinae" title="A programming blog">Machinae Elegantiam</a> <span class="byline">← <a href="/">Russell Harmon</a></span> </span></h1></div><div id="page"><h1 id="string-to-number-conversion-in-c-takes-its-toll">String to Number Conversion in C Takes its Toll</h1><p>Converting a string to a number in C is no simple affair. Many of you may have heard of <a href="http://man7.org/linux/man-pages/man3/atoi.3.html" title="atoi(3)">atoi(3)</a>; one of the ways to convert a string to a number. Unfortunately, modern thinking says that <code>atoi</code> should never be used, and so it’s use is <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoi.html#tag_16_30_07" title="atoi - APPLICATION USAGE">discouraged</a>. Instead, we now have <code>strtol</code>. <sup id="fnref:strtol-and-friends"><a href="#fn:strtol-and-friends" class="footnote">1</a></sup></p><h2 id="whats-wrong-with-atoi">What’s wrong with atoi?</h2><p>The reason for discouraging use of <code>atoi</code> stems from the fact that there is no way to detect if overflow or underflow has occurred, and no way to check if the entire string has been converted (aka there’s no way to detect <code>atoi("123garbage")</code>). Consider the following code:</p><div class="highlight"><pre><code class="c"><span class="c1">// 2^32+1, assuming 32-bit int</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uintmax_plus_one</span> <span class="o">=</span> <span class="s">"4294967297"</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">atoi</span><span class="p">(</span><span class="n">uintmax_plus_one</span><span class="p">));</span></code></pre></div><p>When run instead of printing <code>4294967296</code> as expected, this program will print <code>1</code>! The vast majority of programs do not check for or properly handle this case, and so you can end up with situations like the following:</p><div class="highlight"><pre><code class="c"><span class="c1">// 2^32+1, assuming 32-bit int</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uintmax_plus_one</span> <span class="o">=</span> <span class="s">"4294967297"</span><span class="p">;</span>
<span class="n">malloc</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">uintmax_plus_one</span><span class="p">));</span></code></pre></div><p>Now we’re allocating far less memory than we expected. This problem can quickly become the source of an <a href="https://www.owasp.org/index.php/Integer_overflow" title="Integer overflow">integer overflow</a>.</p><h2 id="enter-strtol">Enter strtol!</h2><p>In order to do the conversion safely, we instead should use <code>strtol</code>. It is unfortunately quite difficult to call this function properly. Consider the following documentation pulled from the BSD Library Functions Manual’s section on <code>strtol</code>:</p><blockquote><p>The strtol(), strtoll(), strtoimax(), and strtoq() functions return the result of the conversion, unless the value would underflow or overflow. If no conversion could be performed, 0 is returned and the global variable errno is set to EINVAL (the last feature is not portable across all platforms). If an overflow or underflow occurs, errno is set to ERANGE and the function return value is clamped according to the following table.</p><table class="neat"><thead><tr><th style="text-align:center">Function</th><th style="text-align:center">underflow</th><th style="text-align:center">overflow</th></tr></thead><tbody><tr><td style="text-align:center">strtol()</td><td style="text-align:center">LONG_MIN</td><td style="text-align:center">LONG_MAX</td></tr><tr><td style="text-align:center">strtoll()</td><td style="text-align:center">LLONG_MIN</td><td style="text-align:center">LLONG_MAX</td></tr><tr><td style="text-align:center">strtoimax()</td><td style="text-align:center">INTMAX_MIN</td><td style="text-align:center">INTMAX_MAX</td></tr><tr><td style="text-align:center">strtoq()</td><td style="text-align:center">LLONG_MIN</td><td style="text-align:center">LLONG_MAX</td></tr></tbody></table></blockquote><p>Based on this, the two ways to check for an overflow are to check if <code>strtol</code> returns 0 or to check if <code>errno</code> is set to <code>ERANGE</code>. There’s another simple case where <code>strtol</code> returns 0 specifically if the input string to <code>strtol</code> is <code>"0"</code>, so in order to accurately detect range errors, we must check for <code>ERANGE</code>. This isn’t quite so simple either however, as if no error has occurred, <code>strtol</code> will not change the value of <code>errno</code>. If this happens, and some previous code has set <code>errno</code> to <code>ERANGE</code> you will erroneously think that a range error has occurred. So now in order to check for range errors you must reset <code>errno</code> to a value that indicates that no error has occurred. Now, what value is that? Thankfully, <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/errno.html" title="errno - error return value">POSIX.1-2008</a> has considered this possibility, and defined that “No function in this volume of POSIX.1-2008 shall set errno to 0,” meaning that no error in all of POSIX will have the value 0. So now we can do the following:</p><div class="highlight"><pre><code class="c"><span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LONG_MIN</span>:
		<span class="c1">// underflow</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LONG_MAX</span>:
		<span class="c1">// overflow</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// impossible</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// something else happened. die die die</span>
<span class="p">}</span></code></pre></div><p>But wait, there’s more! This works fine for detecting range errors, but fails to detect garbage at the end of the string. Thankfully, <code>strtol</code> lets us handle this too via it’s <code>char **endptr</code> argument.</p><blockquote><p>If endptr is not NULL, strtol() stores the address of the first invalid character in *endptr. If there were no digits at all, however, strtol() stores the original value of str in *endptr. (Thus, if *str is not `\0’ but **endptr is `\0’ on return, the entire string was valid.)</p></blockquote><p>Using this, we can detect if there was garbage at the end of the string by passing in a <code>char **</code> value for <code>endptr</code>.</p><div class="highlight"><pre><code class="c"><span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">endptr</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LONG_MIN</span>:
		<span class="c1">// underflow</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LONG_MAX</span>:
		<span class="c1">// overflow</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// impossible</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// something else happened. die die die</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endptr</span> <span class="o">!=</span> <span class="err">'\</span><span class="mi">0</span><span class="err">'</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// garbage at end of string</span>
<span class="p">}</span></code></pre></div><p>And now we’ve turned a relatively simple one-line call to <code>atoi</code> into twenty lines of code. <a href="http://www.fmylife.com" title="Fuck my Life">FML</a></p><h2 id="enter-strtonum">Enter strtonum</h2><p>The great folks over at <a href="http://openbsd.org/">OpenBSD</a> have made a nice replacement for <code>strtol</code> which fixes all of the issues discussed. Called <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strtonum" title="strtonum - reliably convert string value to an integer">strtonum</a>, the function doesn’t allow trailing characters and makes it easy to determine if a range error has occurred. The one drawback is that <code>strtonum</code> is an OpenBSD extension, and so is not found in any standard. If you want to use <code>strtonum</code> on other platforms, you can grab the source <a href="http://anoncvs.estpak.ee/cgi-bin/cgit/openbsd-src/tree/lib/libc/stdlib/strtonum.c">here</a>.</p><div class="footnotes"><ol><li id="fn:strtol-and-friends"><p><code>strtol</code>, short for “string to long” is only one of a few of such functions for converting from a string to a number. Also in this family are <a href="http://man7.org/linux/man-pages/man3/strtol.3.html" title="strtol(3)">strtoimax</a>, <a href="http://man7.org/linux/man-pages/man3/strtol.3.html" title="strtol(3)">strtoll</a> and <a href="http://man7.org/linux/man-pages/man3/strtol.3.html" title="strtol(3)">strtoq</a>. <a href="#fnref:strtol-and-friends" class="reversefootnote">↩</a></p></li></ol></div></div><div id="disqus"><div id="disqus_thread"></div> <script>var disqus_shortname="eatnumber1",disqus_identifier="/blog/2014-05-19/strtol-error-checking";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="http://"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><noscript> Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript"> comments powered by Disqus. </a> </noscript> <a href="http://disqus.com" class="dsq-brlink"> blog comments powered by <span class="logo-disqus">Disqus</span> </a></div><div id="footer"> <address> <span class="copyright"> Content by <a rel="author" href="/">Russell Harmon</a>. Design by <a href="http://mark.reid.name/info/site.html">Mark Reid</a> <br/> (<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Some rights reserved</a>) </span> <span class="engine"> Powered by <a href="http://jekyllrb.com/" title="A static, minimalist CMS">Jekyll</a>. Hosted by <a href="http://pages.github.com/">GitHub</a>. </span> <address></div></div> <script>var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-10349264-2"]),_gaq.push(["_trackPageview"]),function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https://ssl":"http://www")+".google-analytics.com/ga.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html>